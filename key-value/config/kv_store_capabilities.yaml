KVStoreCapabilities:
  consistency:
    type: string                 # enum: ["strong", "bounded_staleness", "session", "consistent_prefix", "eventual"]
    tunable: bool                # whether user can choose consistency level per-operation
    linearizableReads: bool      # strict linearizability guarantees for reads
    linearizableWrites: bool     # strict linearizability guarantees for writes
    readMyWrites: bool           # session-level guarantee
    monotonicReads: bool         # no going back in time for reads
    prefixReads: bool            # reads never see out-of-order writes

  durability:
    persistence: string          # enum: ["memory_only", "disk_single_node", "disk_replicated", "multi_az", "multi_region"]
    replicationSync: string      # enum: ["none", "async", "quorum_sync", "full_sync"]
    writeAcknowledgement: string # enum: ["local_commit", "quorum_commit", "multi_region_commit"]

  availability:
    model: string                # enum: ["single_node", "leader_replication", "multi_master", "quorum"]
    tolerantToRegionFailure: bool
    tolerantToNodeFailure: bool

  conflictResolution:
    strategy: string             # enum: ["none", "last_write_wins", "timestamp", "vector_clock", "custom_logic", "merge"]
    deterministic: bool          # whether conflicts resolve deterministically
    clientProvidedVersion: bool  # whether client may supply version vector, timestamp, ETag, etc.

  partitioning:
    model: string                # enum: ["single", "hashed", "range", "sharded", "multi_region"]
    autoRebalancing: bool
    maxPartitions: string        # "bounded" | "unbounded" | numeric as string
    partitionKeyRequired: bool

  transactions:
    supportsTransactions: bool       # multi-key read-write transactions
    isolationLevel: string | null    # enum: ["serializable", "snapshot", "read_committed", null]
    crossPartitionTransactions: bool # whether transactions span partitions
    crossRegionTransactions: bool    # whether transactions span regions
    conditionalWrites: bool          # CAS / conditional PUT
    atomicBatch: bool                # atomic batch writes

  caching:
    readCache: bool                  # local or distributed read cache
    writeBuffering: bool             # write-back or write-through
    cacheConsistency: string | null  # enum: ["none", "best_effort", "strong", null]

  performance:
    latencyTier: string              # enum: ["in_memory", "low_latency", "high_throughput", "disk_based"]
    autoScaling: bool

  dataModel:
    supportsTTL: bool                # per-key expiration
    supportsAttributes: bool         # metadata per key/value
    maxItemSizeKB: int | null
    maxValueSizeKB: int | null
    schemaFlexibility: string        # enum: ["pure_kv", "kv_document", "wide_column"]

  failures:
    crashLossPossible: bool          # can acknowledged writes be lost?
    staleReadsPossible: bool         # can reads observe old versions?
    lostUpdatePossible: bool         # write-write conflicts possible without protection?
    splitBrainPossible: bool         # divergent replicas possible under certain failures?
    reorderingPossible: bool         # can writes be observed out of order?
    inconsistencyWindow: string|null # e.g. "ms", "seconds", "region RTT", or null for none
