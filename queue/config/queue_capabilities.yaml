QueueCapabilities:
  delivery:
    type: string            # enum: ["at_most_once", "at_least_once", "exactly_once"]
    scopedTo: string        # enum: ["message", "group", "partition", "stream"]

  ordering:
    type: string            # enum: ["none", "best_effort", "fifo_global", "fifo_group", "fifo_partition"]
    key: string | null      # field used to define group/partition (e.g. "messageGroupId", "partitionKey")

  durability:
    persistence: string     # enum: ["memory_only", "disk_single_node", "disk_replicated", "multi_az", "multi_region"]
    replicationSync: string # enum: ["none", "async", "quorum_sync", "full_sync"]
    maxRetention:
      type: string          # enum: ["bounded", "unbounded"]
      duration: string|null # null if unbounded

  acknowledgement:
    pattern: string         # enum: ["delete_on_receive", "explicit_ack", "offset_commit", "transactional"]
    possibleRedelivery: bool # Whether messages may be re-delivered after a crash or timeout
    clientControlledOffset: bool # Whether client controls position (offset) separately from reading

  visibility:
    hasVisibilityTimeout: bool    
    lockBehaviour: string         # enum: ["none", "peek_lock", "lease", "offset_only"]
    redeliveryOnTimeout: bool     # messages return if not acked in time

  partitioning:
    model: string                 # enum: ["single", "partitions", "shards", "consumer_groups"]
    orderingScope: string         # enum: ["queue", "partition", "group"]
    maxPartitions: string         # "bounded" | "unbounded" | numeric as string
    autoScaling: bool

  messageModel:
    maxMessageSizeKB: int | null  # null if abstract / not specified
    supportsBatching: bool
    supportsAttributes: bool      # metadata properties

  transactions:
    supportsTransactions: bool    # multi-message or multi-queue tx
    supportsExactlyOnceTx: bool   # exactly-once within transactions
    crossEntityTransactions: bool # tx across queues/topics or other resources

  failures:
    # On crash of node/region, what can happen to enqueued but unacknowledged messages?
    crashLossPossible: bool       # can acknowledged messages be lost under documented assumptions?
    duplicatePossible: bool       # can duplicates appear across failures?
    reorderingPossible: bool      # can messages be reordered vs enqueue time?
